
use neon::scope::{RootScope};
use neon::js::{Value, Object};
use neon::js::{
    JsObject,
    JsString,
    JsValue,
};
use neon::mem::{Handle, Managed};

use util::{
    get_obj,
    get_fn,
};
use util::dangerous_style_value::dangerous_style_value;

/**
 * Operations for dealing with CSS properties.
 */


/**
 * This creates a string that is expected to be equivalent to the style
 * attribute generated by server-side rendering. It by-passes warnings and
 * security checks so it's not safe to use this value for anything other than
 * comparison. It is only used in DEV for SSR validation.
 */
pub fn create_dangerous_string_for_styles(
    scope: &mut RootScope,
    styles: JsObject
) {
    // TODO
}

/**
 * Sets the value for multiple styles on a node.  If a value is specified as
 * '' (empty string), the corresponding style property will be unset.
 *
 * @param {DOMElement} node
 * @param {object} styles
 */
pub fn set_value_for_styles(
    scope: &mut RootScope,
    node: &mut JsObject,
    styles: JsObject,
    getStack: ()
) {
    let style = get_obj(scope, node.to_raw(), "style");
    let own_property_names: Vec<Handle<JsValue>> = styles
        .get_own_property_names(scope)
        .unwrap()
        .to_vec(scope)
        .unwrap();
    for style_name in own_property_names {
        let mut style_name: String = style_name
            .downcast::<JsString>()
            .unwrap()
            .value();
        let is_custom_property = style_name.starts_with("--");

        // TODO:
        // if (__DEV__) {
        //     if (!isCustomProperty) {
        //         warnValidStyle(styleName, styles[styleName], getStack);
        //     }
        // }

        let style_value = dangerous_style_value(
            style_name.as_str(),
            styles.get(scope, style_name.as_str()).unwrap(),
            is_custom_property,
        );
        if style_name == "float" {
            style_name = "cssFloat".to_string();
        }
        if is_custom_property {
            let this = style.as_value(scope);
            let style_name_handle = JsString::new(scope, style_name.as_str())
                .unwrap();
            let style_value_handle = JsString::new(scope, style_value.as_str())
                .unwrap();
            get_fn(scope, style.to_raw(), "setProperty")
                .call(scope, this, vec![style_name_handle, style_value_handle])
                .unwrap();
        } else {
            style.set(
                style_name.as_str(),
                JsString::new(scope, style_value.as_str()).unwrap(),
            ).unwrap();
        }
    }
}
